{"\/\/ Hello, and welcome to hacking node.js!\n\/\/\n\/\/ This file is invoked by `node::RunBootstrapping()` in `src\/node.cc`, and is\n\/\/ responsible for setting up node.js core before executing main scripts\n\/\/ under `lib\/internal\/main\/`.\n\/\/\n\/\/ This file is expected not to perform any asynchronous operations itself\n\/\/ when being executed - those should be done in either\n\/\/ `lib\/internal\/bootstrap\/pre_execution.js` or in main scripts. The majority\n\/\/ of the code here focuses on setting up the global proxy and the process\n\/\/ object in a synchronous manner.\n\/\/ As special caution is given to the performance of the startup process,\n\/\/ many dependencies are invoked lazily.\n\/\/\n\/\/ Scripts run before this file:\n\/\/ - `lib\/internal\/per_context\/primordials.js`: to save copies of JavaScript\n\/\/   builtins that won't be affected by user land monkey-patching for internal\n\/\/   modules to use.\n\/\/ - `lib\/internal\/bootstrap\/loaders.js`: to setup internal binding and\n\/\/   module loaders, including `process.binding()`, `process._linkedBinding()`,\n\/\/   `internalBinding()` and `NativeModule`.\n\/\/\n\/\/ This file is run to bootstrap both the main thread and the worker threads.\n\/\/ After this file is run, certain properties are setup according to the\n\/\/ configuration of the Node.js instance using the files in\n\/\/ `lib\/internal\/bootstrap\/switches\/`.\n\/\/\n\/\/ Then, depending on how the Node.js instance is launched, one of the main\n\/\/ scripts in `lib\/internal\/main` will be selected by C++ to start the actual\n\/\/ execution. They may run additional setups exported by\n\/\/ `lib\/internal\/bootstrap\/pre_execution.js` depending on the runtime states.\n\n'use strict';\n\n\/\/ This file is compiled as if it's wrapped in a function with arguments\n\/\/ passed by node::RunBootstrapping()\n\/* global process, require, internalBinding, primordials *\/\n\nsetupPrepareStackTrace();\n\nconst {\n  JSONParse,\n  ObjectDefineProperty,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  SymbolToStringTag,\n} ":" primordials;\nconst config = internalBinding('config');\nconst { deprecate } = require('internal\/util');\n\nsetupProcessObject();\n\nsetupGlobalProxy();\nsetupBuffer();\n\nprocess.domain = null;\nprocess._exiting = false;\n\n\/\/ process.config is serialized config.gypi\nprocess.config = JSONParse(internalBinding('native_module').config);\n\n\/\/ Bootstrappers for all threads, including worker threads and main thread\nconst perThreadSetup = require('internal\/process\/per_thread');\nconst rawMethods = internalBinding('process_methods');\n\n\/\/ Set up methods on the process object for all threads\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n\n  \/\/ TODO(joyeecheung): either remove them or make them public\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n\n  \/\/ TODO(joyeecheung): remove these\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.hrtime = wrapped.hrtime;\n  process.hrtime.bigint = wrapped.hrtimeBigInt;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nconst credentials = internalBinding('credentials');\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\n\n\/\/ Setup the callbacks that node::AsyncWrap will call when there are hooks to\n\/\/ process. They use the same functions as the JS embedder API. These callbacks\n\/\/ are setup immediately to prevent async_wrap.setupHooks() from being hijacked\n\/\/ and the cost of doing so is negligible.\nconst { nativeHooks } = require('internal\/async_hooks');\ninternalBinding('async_wrap').setupHooks(nativeHooks);\n\nconst {\n  setupTaskQueue,\n  queueMicrotask\n} = require('internal\/process\/task_queues');\n\nif (!config.noBrowserGlobals) {\n  \/\/ Override global console from the one provided by the VM\n  \/\/ to the one implemented by Node.js\n  \/\/ https:\/\/console.spec.whatwg.org\/#console-namespace\n  exposeNamespace(global, 'console', createGlobalConsole(global.console));\n\n  const { URL, URLSearchParams } = require('internal\/url');\n  \/\/ https:\/\/url.spec.whatwg.org\/#url\n  exposeInterface(global, 'URL', URL);\n  \/\/ https:\/\/url.spec.whatwg.org\/#urlsearchparams\n  exposeInterface(global, 'URLSearchParams', URLSearchParams);\n\n  const {\n    TextEncoder, TextDecoder\n  } = require('internal\/encoding');\n  \/\/ https:\/\/encoding.spec.whatwg.org\/#textencoder\n  exposeInterface(global, 'TextEncoder', TextEncoder);\n  \/\/ https:\/\/encoding.spec.whatwg.org\/#textdecoder\n  exposeInterface(global, 'TextDecoder', TextDecoder);\n\n  \/\/ https:\/\/html.spec.whatwg.org\/multipage\/webappapis.html#windoworworkerglobalscope\n  const timers = require('timers');\n  defineOperation(global, 'clearInterval', timers.clearInterval);\n  defineOperation(global, 'clearTimeout', timers.clearTimeout);\n  defineOperation(global, 'setInterval', timers.setInterval);\n  defineOperation(global, 'setTimeout', timers.setTimeout);\n\n  defineOperation(global, 'queueMicrotask', queueMicrotask);\n\n  \/\/ Non-standard extensions:\n  defineOperation(global, 'clearImmediate', timers.clearImmediate);\n  defineOperation(global, 'setImmediate', timers.setImmediate);\n}\n\n\/\/ Set the per-Environment callback that will be called\n\/\/ when the TrackingTraceStateObserver updates trace state.\n\/\/ Note that when NODE_USE_V8_PLATFORM is true, the observer is\n\/\/ attached to the per-process TracingController.\nconst { setTraceCategoryStateUpdateHandler } = internalBinding('trace_events');\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\n\n\/\/ process.allowedNodeEnvironmentFlags\nObjectDefineProperty(process, 'allowedNodeEnvironmentFlags', {\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  },\n  \/\/ If the user tries to set this to another value, override\n  \/\/ this completely to that value.\n  set(value) {\n    ObjectDefineProperty(this, 'allowedNodeEnvironmentFlags', {\n      value,\n      configurable: true,\n      enumerable: true,\n      writable: true\n    });\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\/\/ process.assert\nprocess.assert = deprecate(\n  perThreadSetup.assert,\n  'process.assert() is deprecated. Please use the `assert` module instead.',\n  'DEP0100');\n\n\/\/ TODO(joyeecheung): this property has not been well-maintained, should we\n\/\/ deprecate it in favor of a better API?\nconst { isDebugBuild, hasOpenSSL, hasInspector } = config;\nObjectDefineProperty(process, 'features', {\n  enumerable: true,\n  writable: false,\n  configurable: false,\n  value: {\n    inspector: hasInspector,\n    debug: isDebugBuild,\n    uv: true,\n    ipv6: true,  \/\/ TODO(bnoordhuis) ping libuv\n    tls_alpn: hasOpenSSL,\n    tls_sni: hasOpenSSL,\n    tls_ocsp: hasOpenSSL,\n    tls: hasOpenSSL,\n    cached_builtins: config.hasCachedBuiltins,\n  }\n});\n\n{\n  const {\n    onGlobalUncaughtException,\n    setUncaughtExceptionCaptureCallback,\n    hasUncaughtExceptionCaptureCallback\n  } = require('internal\/process\/execution');\n\n  \/\/ For legacy reasons this is still called `_fatalException`, even\n  \/\/ though it is now a global uncaught exception handler.\n  \/\/ The C++ land node::errors::TriggerUncaughtException grabs it\n  \/\/ from the process object because it has been monkey-patchable.\n  \/\/ TODO(joyeecheung): investigate whether process._fatalException\n  \/\/ can be deprecated.\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback =\n    setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback =\n    hasUncaughtExceptionCaptureCallback;\n}\n\nconst { emitWarning } = require('internal\/process\/warning');\nprocess.emitWarning = emitWarning;\n\n\/\/ We initialize the tick callbacks and the timer callbacks last during\n\/\/ bootstrap to make sure that any operation done before this are synchronous.\n\/\/ If any ticks or timers are scheduled before this they are unlikely to work.\n{\n  const { nextTick, runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  \/\/ Used to emulate a tick manually in the JS land.\n  \/\/ A better name for this function would be `runNextTicks` but\n  \/\/ it has been exposed to the process object so we keep this legacy name\n  \/\/ TODO(joyeecheung): either remove it or make it public\n  process._tickCallback = runNextTicks;\n\n  const { getTimerCallbacks } = require('internal\/timers');\n  const { setupTimers } = internalBinding('timers');\n  const { processImmediate, processTimers } = getTimerCallbacks(runNextTicks);\n  \/\/ Sets two per-Environment callbacks that will be run from libuv:\n  \/\/ - processImmediate will be run in the callback of the per-Environment\n  \/\/   check handle.\n  \/\/ - processTimers will be run in the callback of the per-Environment timer.\n  setupTimers(processImmediate, processTimers);\n  \/\/ Note: only after this point are the timers effective\n}\n\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException,\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  const {\n    prepareStackTrace,\n    fatalExceptionStackEnhancers: {\n      beforeInspector,\n      afterInspector\n    }\n  } = require('internal\/errors');\n  \/\/ Tell our PrepareStackTraceCallback passed to the V8 API\n  \/\/ to call prepareStackTrace().\n  setPrepareStackTraceCallback(prepareStackTrace);\n  \/\/ Set the function used to enhance the error stack for printing\n  setEnhanceStackForFatalException(beforeInspector, afterInspector);\n}\n\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto, EventEmitter.prototype);\n  EventEmitter.call(process);\n  ObjectDefineProperty(process, SymbolToStringTag, {\n    enumerable: false,\n    writable: true,\n    configurable: false,\n    value: 'process'\n  });\n  \/\/ Make process globally available to users by putting it on the global proxy\n  ObjectDefineProperty(global, 'process', {\n    value: process,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n}\n\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(global, SymbolToStringTag, {\n    value: 'global',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n}\n\nfunction setupBuffer() {\n  const { Buffer } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  \/\/ Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n\n  ObjectDefineProperty(global, 'Buffer', {\n    value: Buffer,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n}\n\nfunction createGlobalConsole(consoleFromVM) {\n  const consoleFromNode =\n    require('internal\/console\/global');\n  if (config.hasInspector) {\n    const inspector = require('internal\/util\/inspector');\n    \/\/ This will be exposed by `require('inspector').console` later.\n    inspector.consoleFromVM = consoleFromVM;\n    \/\/ TODO(joyeecheung): postpone this until the first time inspector\n    \/\/ is activated.\n    inspector.wrapConsole(consoleFromNode, consoleFromVM);\n    const { setConsoleExtensionInstaller } = internalBinding('inspector');\n    \/\/ Setup inspector command line API.\n    setConsoleExtensionInstaller(inspector.installConsoleExtensions);\n  }\n  return consoleFromNode;\n}\n\n\/\/ https:\/\/heycam.github.io\/webidl\/#es-namespaces\nfunction exposeNamespace(target, name, namespaceObject) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: namespaceObject\n  });\n}\n\n\/\/ https:\/\/heycam.github.io\/webidl\/#es-interfaces\nfunction exposeInterface(target, name, interfaceObject) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: interfaceObject\n  });\n}\n\n\/\/ https:\/\/heycam.github.io\/webidl\/#define-the-operations\nfunction defineOperation(target, name, method) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    value: method\n  });\n}\n"}